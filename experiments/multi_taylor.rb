#!/usr/bin/env ruby
# Generates a piecewise interpolated approximation of a Sage expression from
# multiple Taylor series.
#
# Usage: $0 "expression" order around [around...]
#
# Example: $0 'sin(x)' 5 -3 -1 1 3

require 'bundler/setup'
require 'pry-byebug'
require 'shellwords'
require 'mb-math'

def sage(cmd)
  puts "  \e[1mSage command:\e[0m\n    #{MB::U.syntax(cmd, :python).lines.join("    ")}"
  `sage -c #{cmd.shellescape}`.strip.lines.map(&:strip)
end

# Computes the numerical derivative of the given +order+ of +f+ at +x+.  The
# +order+ may be a list of orders.
def derivative(f, x, order)
  cmd = [
    "f = #{f}",
    *order.map { |o| "print(derivative(f, #{o})(x=#{x}).n())" }
  ]
  sage(cmd.join("\n")).map { |n|
    Float(n) rescue Complex(n.sub('*I', 'i').gsub(' ', ''))
  }
end

def taylor_coeffs(f, around, order)
  @taylor_memo ||= {}
  @taylor_memo[[f, around, order]] ||= derivative(f, around, (order + 1).times).map.with_index { |num, o|
    denom = o.downto(1).reduce(1, :*)
    num / denom
  }
end

def taylor_expression(coeffs, around, order)
  terms = coeffs.map.with_index { |c, idx|
    if idx == 0
      c
    else
      if c.real? && c < 0
        prefix = ' - '
      else
        prefix = ' + '
      end

      "#{prefix}#{c.abs} * (x - #{around}) ** #{idx}"
    end
  }
  terms.join
end

raise MB::U.read_header_comment.join.gsub('$0', $0) if ARGV.length < 3 || ARGV.include?('--help')
f = ARGV.shift
order = Integer(ARGV.shift)
around = ARGV.map { |v|
  Float(v) rescue Complex(v)
}.sort_by { |v| [v.real, v.imag] }


# Calculate coefficients and generate individual Taylor series expressions
puts "\n\e[1mGenerating \e[33m#{around.length}\e[0;1m Taylor series of \e[36m#{f}\e[0;1m of order \e[1;35m#{order}\e[0;1m at #{around.map { |v| "\e[1;31m#{v}\e[0m" }.join(', ')}.\n\n"

expressions = around.each_with_index.map { |a, idx|
  puts "\n  \e[1mSeries \e[33m#{idx + 1}\e[0;1m around \e[31m#{a}\e[0m"

  coefficients = taylor_coeffs(f, a, order)
  puts "  \e[1mCoefficients:\e[0m"
  puts "    #{MB::U.highlight(coefficients).lines.join("    ")}"

  expression = taylor_expression(coefficients, a, order)
  puts "  \e[1mExpression:\e[0m"
  puts "    #{MB::U.syntax(expression).lines.join("    ")}"

  expression
}


# Generate Ruby code
# TODO: Maybe sort terms so smallest coefficients are added first (to try to
# increase floating point accuracy)
code = "# Automatically generated multi-Taylor series expansion of #{f}\n"
code << "# Uses order #{order} expansions around #{around.join(', ')}\n"
code << "# Generated by #{$0} from mb-math\n"
code << "def #{"taylor_#{f}".gsub(/[^a-z0-9]+/, '_').gsub(/_+$/, '')}(x)\n"

if around.length == 1
  code << expressions[0]
  code << "\n"
  code << "end\n"
else
  names = around.map.with_index { |a, idx|
    "taylor_#{f}_x#{idx + 1}".gsub(/[^a-z0-9]+/, '_').gsub(/_+$/, '')
  }

  code << "  case\n"
  code << "  when x < #{around[0]}\n    #{names[0]}(x)\n\n"

  0.upto(around.length - 2) do |idx|
    expression_1 = expressions[idx]
    expression_2 = expressions[idx + 1]

    code << "  when x < #{around[idx + 1]} # #{around[idx]} through #{around[idx + 1]}\n"
    code << "    a = #{names[idx]}(x)\n"
    code << "    b = #{names[idx + 1]}(x)\n"
    code << "    blend = MB::M.scale(x, #{around[idx]}..#{around[idx + 1]}, 0..1)\n"
    code << "    MB::M.interp(a, b, blend)\n\n"
  end

  code << "  else # above #{around[-1]}\n    #{names[-1]}(x)\n"

  code << "  end\nend\n\n"

  expressions.each_with_index do |x, idx|
    code << "# Generated Taylor series expansion of #{f} around #{around[idx]}\n"
    code << "def #{names[idx]}(x)\n"
    code << "  #{x}\n"
    code << "end\n\n"
  end
end

puts "\n\e[1mFinal code:\e[0m"
puts "  #{MB::U.syntax(code).lines.join('  ')}"
