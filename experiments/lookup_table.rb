#!/usr/bin/env ruby
# Generates code for a lookup table for the given expression.
#
# Usage: $0 "expression" min max steps
#
# Examples:
#     $0 'cos(x)' -3.14159265 3.14159265 37

require 'bundler/setup'
require 'pry-byebug'
require 'shellwords'
require 'mb-math'

def sage(cmd)
  puts "\e[1mSage command:\e[0m\n  #{MB::U.syntax(cmd, :python).lines.join("  ")}"
  `sage -c #{cmd.shellescape}`.strip.lines.map(&:strip)
end

# Computes the numerical derivative of the given +order+ of +f+ at +x+.  The
# +order+ may be a list of orders.
def evaluate(f, x)
  cmd = [
    "f = #{f}",
    *x.to_enum.map { |v| "print(f(x=#{v}).n())" }
  ]
  sage(cmd.join("\n")).map { |n|
    Float(n) rescue Complex(n.sub('*I', 'i').gsub(' ', ''))
  }
end

raise MB::U.read_header_comment.join.gsub('$0', $0) if ARGV.length != 4 || ARGV.include?('--help')
f = ARGV.shift
min = Float(ARGV.shift)
max = Float(ARGV.shift)
steps = Integer(ARGV.shift)


# Generate lookup table
puts "\n\e[1mGenerating a/an \e[33m#{steps}\e[0;1m-element lookup table of \e[36m#{f}\e[0;1m between \e[1;35m#{min}\e[0;1m and \e[1;32m#{max}\e[0m.\n\n"
range = Numo::DFloat.linspace(min, max, steps)
data = evaluate(f, range)
datatype = data.any?(Complex) ? 'Numo::DComplex' : 'Numo::DFloat'

# Generate Ruby code
# TODO: Maybe sort terms so smallest coefficients are added first (to try to
# increase floating point accuracy)
name = "lookup_#{f}".downcase.gsub(/[^a-z0-9]+/, '_').gsub(/_+$/, '')
upname = name.upcase
code = "# Automatically generated lookup table of #{f} from #{min} to #{max}\n"
code << "# Generated by #{$0} from mb-math\n"
code << "#{upname} = #{datatype}[\n"
code << "  #{MB::U.remove_ansi(MB::U.highlight(data)).lines.join("  ")}"
code << "]\n\n"

code << "# Automatically generated lookup-table-based approximation of #{f}\n"
code << "# Uses #{steps} steps between #{min} and #{max}\n"
code << "# Generated by #{$0} from mb-math\n"
code << "def #{name}(x)\n"
code << "  # TODO: replace lienar interpolation with better interpolation\n"
code << "  idx = MB::M.scale(x, #{min}..#{max}, 0..#{steps - 1})\n"
code << "  idx1 = MB::M.clamp(idx.floor, 0, #{steps - 1})\n"
code << "  idx2 = MB::M.clamp(idx.ceil, 0, #{steps - 1})\n"
code << "  frac = idx - idx1\n"
code << "  MB::M.interp(#{upname}[idx1], #{upname}[idx2], frac)\n"
code << "end\n"

puts "\n\e[1mFinal code:\e[0m"
puts "  #{MB::U.syntax(code).lines.join('  ')}"
