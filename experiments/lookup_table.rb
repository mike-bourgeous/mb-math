#!/usr/bin/env ruby
# Generates code for a lookup table for the given expression.
#
# Usage: $0 "expression" min max steps
#
# Examples:
#     $0 'cos(x)' -3.14159265 3.14159265 37

require 'bundler/setup'
require 'pry-byebug'
require 'shellwords'
require 'mb-math'

def sage(cmd)
  puts "\e[1mSage command:\e[0m\n  #{MB::U.syntax(cmd, :python).lines.join("  ")}"
  `sage -c #{cmd.shellescape}`.strip.lines.map(&:strip)
end

# Computes the numerical derivative of the given +order+ of +f+ at +x+.  The
# +order+ may be a list of orders.
def evaluate(f, x)
  cmd = [
    "f = #{f}",
    *x.to_enum.map { |v| "try:\n    print(f(x=#{v}).n())\nexcept:\n    print(limit(f, x=#{v}).n())" }
  ]
  sage(cmd.join("\n")).map { |n|
    Float(n) rescue Complex(n.sub('*I', 'i').gsub(' ', ''))
  }
end

raise MB::U.read_header_comment.join.gsub('$0', $0) if ARGV.length != 4 || ARGV.include?('--help')
f = ARGV.shift
min = Float(ARGV.shift)
max = Float(ARGV.shift)
steps = Integer(ARGV.shift)


# Generate lookup table
puts "\n\e[1mGenerating a/an \e[33m#{steps}\e[0;1m-element lookup table of \e[36m#{f}\e[0;1m between \e[1;35m#{min}\e[0;1m and \e[1;32m#{max}\e[0m.\n\n"
range = Numo::DFloat.linspace(min, max, steps)
data = evaluate(f, range)
datatype = data.any?(Complex) ? 'Numo::DComplex' : 'Numo::DFloat'
raise 'Length of data from Sage does not match expected number of steps' if data.length != steps

# Generate Ruby code
name = "lookup_#{f}".downcase.gsub(/[^a-z0-9]+/, '_').gsub(/_+$/, '')
upname = name.upcase
code = "# Automatically generated lookup table of #{f} from #{min} to #{max}\n"
code << "# Generated by #{$0} from mb-math\n"
code << "# #{$0} #{f.inspect} #{min} #{max} #{steps}\n"
code << "#{upname} = #{datatype}[\n"
code << "  #{MB::U.remove_ansi(MB::U.highlight(data)).lines.join("  ")}"
code << "]\n\n"

# TODO: Maybe allow choosing interpolation method
# TODO: Maybe allow choosing out-of-bounds behavior (clamp, loop, bounce)
code << "# Automatically generated lookup-table-based approximation of #{f}\n"
code << "# Uses #{steps} steps between #{min} and #{max}\n"
code << "# Generated by #{$0} from mb-math\n"
code << "def #{name}(x)\n"
code << "  offset = MB::M.scale(x, #{min}..#{max}, 0..#{steps - 1})\n"
code << "  idx = MB::M.clamp(offset.floor, 1, #{steps - 3})\n"
code << "  frac = offset - idx\n"
code << "  MB::M.catmull_rom(#{upname}[idx - 1], #{upname}[idx], #{upname}[idx + 1], #{upname}[idx + 2], frac)[1]\n"
code << "end\n"

puts "\n\e[1mFinal code:\e[0m"
puts "  #{MB::U.syntax(code).lines.join('  ')}"
